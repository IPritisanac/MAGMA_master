# Read assigment file generated by MAGMA, and plots it into a bipartite graph
# From terminal, call python assignment_graph.py -h for information on usage

import networkx as nx
import os
import numpy as np
import matplotlib.pyplot as plt
import itertools
import glob
import re

def load_data(fname):
   
    try:
        fin=open(fname,"r")
    except:
        err="could not open %s"%fname
        raise IOError(err)
    
    #read assignment file, and create pdb and peak label lists
    assign={}
    xray_labels=[]
    for line in fin:
        w=line.split()
        
        #prepend temporary label header to NOE peaks to ensure uniqueness against PDB peaks
        wlbl="NOE_"+w[0]
                
        for i in xrange(1, len(w), 1):
            pdblabel = w[i]
            if pdblabel[0] == ":":
                pdblabel = pdblabel[1:]
                w[i] = w[i][1:]
                                
            if pdblabel not in xray_labels:
                xray_labels.append(pdblabel)
        
        if wlbl in list(assign):
            data = assign[wlbl]
            data.extend(w[1:])
            assign[wlbl] = data
        else:
            assign[wlbl] = w[1:]
        
    fin.close()
 
    return assign


def load_folder(folder):

    files = glob.glob("%s/*txt"%folder)
    all_assign = {}
    for f in files:
        print("parsing file %s..."%f)       
        try:
            fin = open(f, "r")
        except:
            err = "could not open %s"%f
            raise IOError(err)

        for line in fin:
            w = line.split()
            if len(w) < 2:
                continue
            
            wlbl="NOE_"+w[0]
            if wlbl in list(all_assign):
                data = all_assign[wlbl]
                data.append(w[1])
                all_assign[wlbl] = data
            else:
                all_assign[wlbl] = [w[1]]
 
        fin.close()

    for k in list(all_assign):
        all_assign[k] = np.unique(np.array(all_assign[k]))

    write_assignment(all_assign, "%s%saggregated.dat"%(folder, os.sep))
    return all_assign


def write_assignment(all_assign, foutname): 
    #write aggregated results
    cnt = []
    for k in list(all_assign):
        cnt.append(len(all_assign[k]))
        
    fout = open(foutname, "w")
    sortedkeys = np.array(list(all_assign))[np.argsort(np.array(cnt))]
    for k in sortedkeys:
        if "_" in k:
            line = "%s "%k.split("_")[1]
        else:
            line = "%s "%k
            
        line += " ".join(all_assign[k])
        fout.write("%s\n"%line)

    fout.close()
    


def analyse_assignment(assign, assign_simp=[], plot=""):
    
    #count unique assignments and identify mistakes (also in multiple assignments)
    cnt_raw = []
    cnt_raw_unique = 0
    cnt_raw_err = 0
    for k in list(assign):
        cnt_raw.append(len(assign[k]))
        if len(assign[k]) == 1:
            cnt_raw_unique += 1
        
        testlbl = re.findall('\d+', k)[0] 
        targets = []
        for t in assign[k]:
            targets.append(re.findall('\d+', t)[0])
            
        if testlbl not in targets:
            print k, assign[k]
            cnt_raw_err += 1
 
    edges_raw = np.sum(np.sum(cnt_raw))
    print("assignment: %s peaks, %s unique solutions, %s mistakes, %s edges\n"%
          (len(assign), cnt_raw_unique, cnt_raw_err, edges_raw))    


    if len(assign_simp) > 0:
        cnt_simp_unique = 0
        cnt_simp_err = 0
        cnt_simp = []
        for k in list(assign_simp):
            cnt_simp.append(len(assign_simp[k]))
            if len(assign_simp[k]) == 1:
                cnt_simp_unique += 1
                
            testlbl = re.findall('\d+', k)[0] 
            targets = []
            for t in assign_simp[k]:
                targets.append(re.findall('\d+', t)[0])

            if testlbl not in targets:
                print k, assign_simp[k]
                cnt_simp_err += 1
        
        edges_simp = np.sum(np.sum(cnt_simp))
        print("simplified assignment: %s peaks, %s unique solutions, %s mistakes, %s edges"%
              (len(assign_simp), cnt_simp_unique, cnt_simp_err, edges_simp))    
 

    if plot.strip() == "":
        return
    
    #summarize performance
    if len(assign_simp) > 0:
        maxval = max(np.max(cnt_raw), np.max(cnt_simp))
    else:
        maxval = np.max(cnt_raw)
    
    r = []
    c = np.array(cnt_raw)
    for i in range(1, maxval):
        r.append([i, np.sum(c == i)])
    
    result_raw = np.array(r)

    if len(assign_simp) > 0:
        r = []
        c = np.array(cnt_simp)
        for i in range(1, maxval):
            r.append([i, np.sum(c == i)])

        result_simp = np.array(r)
        
    #plot results
    fig = plt.figure()
    ax = fig.add_subplot(1, 1, 1) 

    if len(assign_simp) == 0:
        ax.bar(result_raw[:, 0]-0.25, result_raw[:, 1], color="dodgerblue", width=1.0)

    else:
        ax.bar(result_raw[:, 0]-0.5, result_raw[:, 1], color="dodgerblue", width=0.5, label="input (%s)"%edges_raw)
        ax.bar(result_simp[:, 0], result_simp[:, 1], color="tomato", width=0.5, label="simplified (%s)"%edges_simp)


    ax.set_xlabel("possible assignments (#)")
    ax.set_ylabel("occurrences (#)")
    
    ax.set_xticks(range(1, maxval))
    plt.legend(frameon=False)
    plt.savefig(plot)
    
    plt.show()


def simplify_graph(G, all_labels_map, foutname="assignment_simplified.txt"):

    #get "NOE" vertices
    noes = []
    for n in list(all_labels_map):
        if "NOE" in n:
            noes.append(all_labels_map[n])

    #main simplification loop
    maintest = True
    maincnt = 1
    while maintest:
        print("\n pass nb. %s..."%maincnt)
        maincnt += 1
        maintest = False
        cnt_illogical = 0
        
        #find NOEs with unique assignment
        #clear other links pointing to that same atom from otehr NOEs
        print("\n> clearing singles...")
        test = True
        while test:
            cnt_unique = 0
            test = False
            for n in noes:
                links = list(G.edges(n))
                if len(links) == 1:
                    cnt_unique += 1
                    ebunch = list(G.edges(links[0][1]))
                    if len(ebunch) > 1:
                        test = True #found an instance for simplification, loop will be repeated
                        cnt_illogical += len(ebunch) - 1
                        G.remove_edges_from(ebunch)
                        G.add_edge(links[0][0], links[0][1])   
    
        print(">> %s unique assignments"%cnt_unique)    
        print(">> removed %s illogical links"%cnt_illogical)

        #find NOES with two possible assignments
        print("\n> clearing twins...")
        noes_2 = []
        for n in noes:
            links = list(G.edges(n))
            if len(links) == 2:
                noes_2.append(n)
                
        #iterate over pairs and check if they have the same two target atoms
        #if so, remove every other link pointing to those atoms
        test = True
        cnt_illogical = 0
        while test:
            test = False
            for p in itertools.combinations(noes_2, 2):
                target1 = np.array(list(G.edges(p[0])))
                target2 = np.array(list(G.edges(p[1])))
                
                if len(target1) !=2 or len(target2) !=2:
                    continue

                if np.all(target1[:,1] == target2[:,1]):        
                    ebunch1 = list(G.edges(target1[0,1]))
                    ebunch2 = list(G.edges(target1[1,1]))
                    if len(ebunch1) >2 or len(ebunch2) > 2:
                        test = True #found an instance for simplification, inner loop will be repeated
                        maintest = True #found an instance for simplification, main loop will be repeated
                        cnt_illogical += len(ebunch1) + len(ebunch2) - 4  
                        G.remove_edges_from(ebunch1)
                        G.remove_edges_from(ebunch2)
                        G.add_edge(target1[0,0], target1[0,1])
                        G.add_edge(target1[1,0], target1[1,1])
                        G.add_edge(target2[0,0], target1[0,1])
                        G.add_edge(target2[1,0], target1[1,1])

        print(">> %s unique assignments"%cnt_unique)
        print(">> removed %s illogical links"%cnt_illogical)

    #recalculate graph weights
    for n in list(all_labels_map):
        if "NOE" in n:
            links = G.edges(all_labels_map[n])
            if len(links) != 0:
                weight = 100./len(links)
            else:
                weight = 5
                
            for l in links:
                G[l[0]][l[1]]['weight'] = weight
                
    #collect all remaining outputs assignments for output
    assignments = {}
    cnt = []
    for n in list(all_labels_map):
        if "NOE" in n:
            edges = G.edges(all_labels_map[n])
            outline = []
            for e in edges:
                for key in list(all_labels_map):
                    if all_labels_map[key] == e[1]:
                        v = key
                        break
                     
                outline.append("%s"%v)

            assignments["%s"%n.split("_")[1]] = outline
            cnt.append(len(outline))

    write_assignment(assignments, foutname)

    return G, assignments


def make_assigment_graph(assign, outname="assignment.svg", simplify=False):

    #gather all unique noe and xray labels, and sort noe labels by uniqueness
    noe_labels = list(assign)
    xray_labels = []
    cnt_assign = []
    for l in noe_labels:
        cnt_assign.append(len(assign[l]))
        xray_labels.extend(assign[l])
    
    possort = np.argsort(np.array(cnt_assign))
    cnt_assign = np.array(cnt_assign)[possort]
    noe_labels = np.array(noe_labels)[possort]
    xray_labels = np.unique(np.array(xray_labels))
    
    #define position range for xray and noe nodes
    max_size=len(xray_labels)*50.0
    noepos=np.linspace(max_size, 0, len(noe_labels))
    xraypos=np.linspace(max_size, 0, len(xray_labels))

    #methyl color scheme
    clrs={"I":(1.0, 0.97, 0.44),"L":(0.05, 0.5, 0.77),"V":(0.98, 0.00, 0.23),"X":(1.0, 1.0, 1.0)}
    
    #create bipartite graph, insert nodes, manually define positions and set labels
    G=nx.Graph()
    G.pos={} # node location
    G.color={} #node colors
    all_labels={} #map node index to label name in plot
    all_labels_map={} #backmap label to index (using modified peak name, to ensure uniqueness)
    
    all_cnt = 0 #count total amount of nodes
    cnt_xray = 0 #counter to keep track of now many xray nodes have been placed already
    for i, n in enumerate(noe_labels):

        #add peaks node
        all_labels[all_cnt] = n.split("_")[1]
        all_labels_map[n] = all_cnt

        G.add_node(all_cnt, bipartite=1)
        G.node[all_cnt]['pos'] = (0, noepos[i])
        resname=noe_labels[i][-1]
        if resname in clrs.keys():
            G.node[all_cnt]['color'] = clrs[resname]
        else:
            G.node[all_cnt]['color'] = clrs["X"]
    
        all_cnt += 1

        # add associated xray nodes
        for x in assign[n]:
            
            if x in list(all_labels_map):
                continue 
             
            all_labels[all_cnt] = x
            all_labels_map[x]=all_cnt
            
            G.add_node(all_cnt, bipartite=0)
            G.node[all_cnt]['pos'] = (20, xraypos[cnt_xray])
            
            resname=x[-1]
            if resname in clrs.keys():
                G.node[all_cnt]['color'] = clrs[resname]
            else:
                G.node[all_cnt]['color'] = clrs["X"]

            cnt_xray += 1
            all_cnt += 1
    
    #create edges between peak and pdb nodes
    for a in list(assign):
        for n in assign[a]:
            G.add_edge(all_labels_map[a], all_labels_map[n], weight=100./(len(assign[a])))
   
    #simplication routine, on request (will generate a new output file called assignment_simplified.txt)
    if simplify == "yes":
        G, assignments = simplify_graph(G, all_labels_map)
                     
    #prepare graph drawing
    mydpi=80
    fig=plt.figure(1,figsize=(600./mydpi,float(max_size+100)/mydpi),dpi=mydpi)
    fig.patch.set_facecolor('white')
    ax1=fig.add_subplot(111)
    
    #extract edges weights and edges colors
    edges = G.edges()
    weights = np.array([G[u][v]['weight'] for u, v in edges])/10.0

    #get color list
    colors = []
    colors_attr = nx.get_node_attributes(G, 'color')
    for i in range(len(all_labels)):
            colors.append(colors_attr[i])
    
    #get vertices positions
    pos = nx.get_node_attributes(G, 'pos')
    
    #draw graph
    nx.draw_networkx_nodes(G, pos, node_size=1250, node_color=colors, alpha=1.0)
    nx.draw_networkx_edges(G, pos, width=weights, alpha=0.5,edge_color='k')
    nx.draw_networkx_labels(G, pos, all_labels, font_size=12, font_family='sans-serif')
    
    #column headers
    ax1.annotate('PEAK', xy=(0,max_size+50),horizontalalignment='center', fontsize=15, weight="bold")
    ax1.annotate('PDB', xy=(20,max_size+50),horizontalalignment='center', fontsize=15, weight="bold")
    
    #define plot boundaries and save graph
    ax1.set_xlim([-5, 25])
    ax1.set_ylim([-50, max_size+100])
    plt.tight_layout()
    plt.axis('off')
    plt.savefig(outname)

    plt.show()

    if simplify == "yes":
        return assignments


if __name__=="__main__":

    import sys
    import argparse
    
    #create arguments parser
    parser = argparse.ArgumentParser(description='Parse input parameters')
    parser.add_argument('-f', metavar="assignment", default="", help='file with MAGMA assignment')
    parser.add_argument('-d', metavar="directory", default="", help='directory with multiple MAGMA assignments (of the same protein)')
    parser.add_argument('-pg', metavar="plot_graph_name", required=True, help='name of graph plot file')
    parser.add_argument('-ph', metavar="plot_hist_name", default="", help='name of histogram plot file')
    parser.add_argument('-s', metavar="simplify", default="yes", choices=["yes", "no"], help='run simplification routine?')
    
    #parse arguments
    args = vars(parser.parse_args())
    
    outname_graph = args["pg"]
    outname_hist = args["ph"]
    simplify = args["s"]
    fname = args["f"]
    directory = args["d"]
    
    if fname == "" and directory == "":
        print("assignment file or directory must be specified!")
        sys.exit()
    
    if fname != "" and directory != "":
        print("either assignment file or directory should be specified!")
        sys.exit()
    
    if fname != "":
        if not os.path.exists(fname) or not os.path.isfile(fname):
            print("file %s not found!"%fname)
            sys.exit()

        assign = load_data(fname)
    
    else:
        dabs = os.path.abspath(directory)
        print dabs
        if not os.path.exists(dabs) or not os.path.isdir(dabs):
            print("directory %s not found!"%dabs)
            sys.exit()
    
        assign = load_folder(dabs)

    #report some stats on the assignment(s)        
    if simplify == "yes":
        assign_simp = make_assigment_graph(assign, outname_graph, simplify)
        analyse_assignment(assign, assign_simp, plot=outname_hist)
    else:
        make_assigment_graph(assign, outname_graph, simplify)
        analyse_assignment(assign, plot=outname_hist)